#Code for toolbox written by Google Colab, supervised and tested by Will.
#The dataset must contain a field with a field named 'Input_FID' for the tool to function properly. 

{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import arcpy\n",
    "import os\n",
    "import sys\n",
    "import traceback\n",
    "from collections import defaultdict\n",
    "# ---------------------------------------------------------------------------\n",
    "# Helper Functions\n",
    "# ---------------------------------------------------------------------------\n",
    "def validate_inputs(hex_layer, overlay_layer, value_field):\n",
    "    \"\"\"Performs initial validation checks on input layers and fields.\"\"\"\n",
    "    arcpy.AddMessage(\"Validating inputs...\")\n",
    "    if not arcpy.Exists(hex_layer):\n",
    "        arcpy.AddError(f\"Input Hexagon Layer not found: {hex_layer}\")\n",
    "        sys.exit()\n",
    "    if not arcpy.Exists(overlay_layer):\n",
    "        arcpy.AddError(f\"Input Overlay Layer not found: {overlay_layer}\")\n",
    "        sys.exit()\n",
    "    # Check for Input_FID in hexagon layer\n",
    "    hex_desc = arcpy.Describe(hex_layer)\n",
    "    hex_fields = [f.name.upper() for f in arcpy.ListFields(hex_layer)] # Use upper for case-insensitivity\n",
    "    if \"INPUT_FID\" not in hex_fields:\n",
    "        arcpy.AddError(f\"Hexagon Layer '{os.path.basename(hex_layer)}' must contain the field 'Input_FID'.\")\n",
    "        sys.exit()\n",
    "    # Check if the Value Field exists in the overlay layer\n",
    "    overlay_fields = [f.name for f in arcpy.ListFields(overlay_layer)]\n",
    "    if value_field not in overlay_fields:\n",
    "        arcpy.AddError(f\"Value Field '{value_field}' not found in Overlay Layer '{os.path.basename(overlay_layer)}'.\")\n",
    "        sys.exit()\n",
    "    arcpy.AddMessage(\"Input validation successful.\")\n",
    "    return True # Indicate success\n",
    "def get_overlay_properties(overlay_layer):\n",
    "    \"\"\"Describes the overlay layer and determines its properties (type, OID, CRS).\"\"\"\n",
    "    arcpy.AddMessage(\"Describing overlay layer...\")\n",
    "    overlay_desc = None\n",
    "    properties = {}\n",
    "    try:\n",
    "        overlay_desc = arcpy.Describe(overlay_layer)\n",
    "        if not overlay_desc:\n",
    "             raise ValueError(\"Describe object returned by ArcPy is empty or invalid.\")\n",
    "        properties['shape_type'] = overlay_desc.shapeType\n",
    "        properties['oid_field'] = overlay_desc.OIDFieldName\n",
    "        properties['spatial_ref'] = overlay_desc.spatialReference\n",
    "        arcpy.AddMessage(f\"Overlay layer type detected as: {properties['shape_type']}\")\n",
    "    except Exception as desc_error:\n",
    "        arcpy.AddError(f\"Fatal Error: Failed to get properties of the Input Overlay Layer '{os.path.basename(overlay_layer)}'.\")\n",
    "        arcpy.AddError(\"Please ensure the layer is valid, accessible, and not corrupted.\")\n",
    "        arcpy.AddError(f\"Underlying error: {str(desc_error)}\")\n",
    "        sys.exit()\n",
    "    # Determine coordinate system properties\n",
    "    arcpy.AddMessage(\"Determining coordinate system...\")\n",
    "    spatial_ref = properties['spatial_ref']\n",
    "    properties['area_unit'] = \"Unknown Units\"\n",
    "    properties['length_unit'] = \"Unknown Units\"\n",
    "    properties['area_token'] = \"SHAPE@AREA\"\n",
    "    properties['length_token'] = \"SHAPE@LENGTH\"\n",
    "    properties['is_projected'] = None\n",
    "    if spatial_ref and spatial_ref.name and spatial_ref.name != \"Unknown\":\n",
    "        arcpy.AddMessage(f\"Overlay layer Coordinate System: {spatial_ref.name}\")\n",
    "        if hasattr(spatial_ref, 'type'):\n",
    "            if spatial_ref.type == \"Projected\":\n",
    "                arcpy.AddMessage(\"Coordinate System Type: Projected\")\n",
    "                properties['is_projected'] = True\n",
    "                properties['area_unit'] = spatial_ref.linearUnitName if spatial_ref.linearUnitName else \"Unknown Projected Units\"\n",
    "                properties['length_unit'] = spatial_ref.linearUnitName if spatial_ref.linearUnitName else \"Unknown Projected Units\"\n",
    "            elif spatial_ref.type == \"Geographic\":\n",
    "                arcpy.AddMessage(\"Coordinate System Type: Geographic\")\n",
    "                properties['is_projected'] = False\n",
    "                properties['area_unit'] = spatial_ref.angularUnitName if spatial_ref.angularUnitName else \"Unknown Angular Units\"\n",
    "                properties['length_unit'] = spatial_ref.angularUnitName if spatial_ref.angularUnitName else \"Unknown Angular Units\"\n",
    "                arcpy.AddWarning(f\"Overlay layer '{os.path.basename(overlay_layer)}' has a Geographic Coordinate System ({spatial_ref.name}). Length calculations will use planar methods in {properties['length_unit']}. Results may be less accurate. Consider projecting data first.\")\n",
    "            else:\n",
    "                arcpy.AddWarning(f\"Could not definitively determine if the coordinate system '{spatial_ref.name}' is Projected or Geographic (Type: {spatial_ref.type}). Assuming Projected.\")\n",
    "                properties['is_projected'] = True # Default assumption\n",
    "                try: # Attempt to get linear units anyway\n",
    "                    properties['area_unit'] = spatial_ref.linearUnitName if spatial_ref.linearUnitName else \"Unknown Projected Units\"\n",
    "                    properties['length_unit'] = spatial_ref.linearUnitName if spatial_ref.linearUnitName else \"Unknown Projected Units\"\n",
    "                except AttributeError:\n",
    "                     arcpy.AddWarning(\"Could not retrieve linear units for coordinate system.\")\n",
    "        else:\n",
    "             arcpy.AddError(f\"Could not determine Coordinate System type for '{spatial_ref.name}'. The 'type' attribute is missing. Cannot proceed.\")\n",
    "             sys.exit()\n",
    "    else:\n",
    "        arcpy.AddError(f\"Overlay Layer '{os.path.basename(overlay_layer)}' has an undefined or unknown Coordinate System. Please use 'Define Projection'.\")\n",
    "        sys.exit()\n",
    "    arcpy.AddMessage(f\"Units for calculation: Length={properties['length_unit']}, Area={properties['area_unit']}\")\n",
    "    return properties\n",
    "def find_overlay_oid_in_intersect(temp_intersect, overlay_layer_name, original_oid_field):\n",
    "    \"\"\"Attempts to find the OID field from the overlay layer within the intersect output.\"\"\"\n",
    "    arcpy.AddMessage(\"Determining overlay OID field name in intersection output...\")\n",
    "    intersect_fields_list = [f.name for f in arcpy.ListFields(temp_intersect)]\n",
    "    found_overlay_oid_field = None\n",
    "    # Sanitize base name for potential use in FID_ field names (common pattern)\n",
    "    sanitized_overlay_name = ''.join(c if c.isalnum() else '_' for c in overlay_layer_name)\n",
    "    potential_oid_name_1 = f\"FID_{sanitized_overlay_name}\"\n",
    "    potential_oid_name_2 = original_oid_field # Sometimes original name is kept\n",
    "    # Check common patterns first\n",
    "    if potential_oid_name_1 in intersect_fields_list:\n",
    "        found_overlay_oid_field = potential_oid_name_1\n",
    "    elif potential_oid_name_2 in intersect_fields_list:\n",
    "         found_overlay_oid_field = potential_oid_name_2\n",
    "    else: # Fallback search (less precise, handles spaces/truncation by prefix)\n",
    "         overlay_name_prefix = sanitized_overlay_name[:10] # Approximate prefix match\n",
    "         for fld_name in intersect_fields_list:\n",
    "             # Check if field starts with FID_ and overlay prefix matches start of field suffix\n",
    "             if fld_name.startswith(\"FID_\") and overlay_name_prefix.startswith(fld_name[4:]):\n",
    "                 found_overlay_oid_field = fld_name; break\n",
    "         if not found_overlay_oid_field:\n",
    "             try: # Last attempt using alias name from describe\n",
    "                 int_desc = arcpy.Describe(temp_intersect)\n",
    "                 for fld in int_desc.fields:\n",
    "                     if fld.aliasName == original_oid_field:\n",
    "                         found_overlay_oid_field = fld.name; break\n",
    "             except: pass # Ignore describe error here if it happens\n",
    "    if not found_overlay_oid_field:\n",
    "         arcpy.AddError(f\"Could not reliably determine the OID field from '{overlay_layer_name}' in the intersection result '{os.path.basename(temp_intersect)}'. Expected something like '{potential_oid_name_1}' or '{potential_oid_name_2}'. Check intermediate data fields.\")\n",
    "         sys.exit()\n",
    "    arcpy.AddMessage(f\"Using field '{found_overlay_oid_field}' to link intersection pieces back to original overlay polygons.\")\n",
    "    return found_overlay_oid_field\n",
    "def process_polylines(hex_layer, overlay_layer, value_field, length_token, temp_intersect_path):\n",
    "    \"\"\"Performs intersect and calculates length-weighted average for polyline overlays.\"\"\"\n",
    "    arcpy.AddMessage(f\"Processing Overlay Layer as Polyline (Length-Weighted Average)...\")\n",
    "    final_values = {}\n",
    "    hex_data = defaultdict(lambda: {'weighted_sum': 0.0, 'total_length': 0.0})\n",
    "    # Perform Intersect\n",
    "    arcpy.AddMessage(f\"Intersecting layers (writing temporary data to {temp_intersect_path})...\")\n",
    "    arcpy.analysis.Intersect([hex_layer, overlay_layer], temp_intersect_path, \"ALL\", output_type=\"INPUT\")\n",
    "    # Check if temp_intersect was created successfully before using cursor\n",
    "    if not arcpy.Exists(temp_intersect_path):\n",
    "         arcpy.AddError(f\"Temporary intersect layer '{temp_intersect_path}' was not created successfully. Cannot proceed.\")\n",
    "         sys.exit()\n",
    "    # Calculate weighted sum and total length\n",
    "    intersect_fields = [\"Input_FID\", value_field, length_token]\n",
    "    processed_segments = 0\n",
    "    arcpy.AddMessage(\"Calculating length-weighted average...\")\n",
    "    with arcpy.da.SearchCursor(temp_intersect_path, intersect_fields) as cursor:\n",
    "        for row in cursor:\n",
    "            hex_id, val, length = row\n",
    "            if hex_id is not None and val is not None and length is not None and length > 0:\n",
    "                 try:\n",
    "                    numeric_val = float(val)\n",
    "                    hex_data[hex_id]['weighted_sum'] += numeric_val * length\n",
    "                    hex_data[hex_id]['total_length'] += length\n",
    "                    processed_segments += 1\n",
    "                 except (ValueError, TypeError):\n",
    "                     arcpy.AddWarning(f\"Could not convert value '{val}' to numeric for Hex ID {hex_id}. Skipping segment.\")\n",
    "                     continue\n",
    "    arcpy.AddMessage(f\"Processed {processed_segments} intersecting polyline segments.\")\n",
    "    # Calculate final average values\n",
    "    for hex_id, data in hex_data.items():\n",
    "        if data['total_length'] > 0:\n",
    "            final_values[hex_id] = data['weighted_sum'] / data['total_length']\n",
    "    return final_values\n",
    "def process_polygons(hex_layer, overlay_layer, value_field, overlay_oid_field, area_token, temp_intersect_path):\n",
    "    \"\"\"Performs intersect and calculates area-proportional sum for polygon overlays.\"\"\"\n",
    "    arcpy.AddMessage(f\"Processing Overlay Layer as Polygon (Area-Proportional Sum)...\")\n",
    "    final_values = {}\n",
    "    hex_data = defaultdict(lambda: {'allocated_sum': 0.0})\n",
    "    # 1. Get Original Overlay Areas\n",
    "    arcpy.AddMessage(\"Calculating original overlay polygon areas...\")\n",
    "    overlay_areas = {}\n",
    "    with arcpy.da.SearchCursor(overlay_layer, [overlay_oid_field, area_token]) as cursor:\n",
    "         for oid, area in cursor:\n",
    "             if area is not None and area > 0:\n",
    "                 overlay_areas[oid] = area\n",
    "    if not overlay_areas:\n",
    "         arcpy.AddWarning(\"Could not calculate positive areas for any overlay polygons.\")\n",
    "    # 2. Perform Intersect\n",
    "    arcpy.AddMessage(f\"Intersecting layers (writing temporary data to {temp_intersect_path})...\")\n",
    "    arcpy.analysis.Intersect([hex_layer, overlay_layer], temp_intersect_path, \"ALL\", output_type=\"INPUT\")\n",
    "    # Check if temp_intersect was created successfully\n",
    "    if not arcpy.Exists(temp_intersect_path):\n",
    "         arcpy.AddError(f\"Temporary intersect layer '{temp_intersect_path}' was not created successfully. Cannot proceed.\")\n",
    "         sys.exit()\n",
    "    # 3. Find overlay OID field in intersect output\n",
    "    overlay_layer_name = os.path.basename(overlay_layer)\n",
    "    found_overlay_oid_field = find_overlay_oid_in_intersect(temp_intersect_path, overlay_layer_name, overlay_oid_field)\n",
    "    # 4. Calculate Sum of Allocated Values\n",
    "    intersect_fields = [\"Input_FID\", found_overlay_oid_field, value_field, area_token]\n",
    "    processed_pieces = 0\n",
    "    arcpy.AddMessage(\"Calculating area-proportional sum...\")\n",
    "    with arcpy.da.SearchCursor(temp_intersect_path, intersect_fields) as cursor:\n",
    "        for row in cursor:\n",
    "            hex_id, overlay_oid, val, intersect_area = row\n",
    "            if hex_id is not None and overlay_oid is not None and val is not None and intersect_area is not None and intersect_area > 0:\n",
    "                original_area = overlay_areas.get(overlay_oid)\n",
    "                if original_area: # Checks not None and > 0\n",
    "                     try:\n",
    "                         numeric_val = float(val)\n",
    "                         proportion = intersect_area / original_area\n",
    "                         allocated_value = numeric_val * proportion\n",
    "                         hex_data[hex_id]['allocated_sum'] += allocated_value\n",
    "                         processed_pieces += 1\n",
    "                     except (ValueError, TypeError):\n",
    "                         arcpy.AddWarning(f\"Could not convert value '{val}' to numeric for Hex ID {hex_id}, OID {overlay_oid}.\")\n",
    "                         continue\n",
    "    arcpy.AddMessage(f\"Processed {processed_pieces} intersecting polygon pieces.\")\n",
    "    # 5. Prepare final values dictionary\n",
    "    final_values = {hex_id: data['allocated_sum'] for hex_id, data in hex_data.items()}\n",
    "    return final_values\n",
    "def create_and_populate_output(hex_layer, output_fc, output_field_name, output_field_alias, final_values):\n",
    "    \"\"\"Creates the output FC, adds the field, and populates it with calculated values.\"\"\"\n",
    "    arcpy.AddMessage(f\"Creating output feature class: {output_fc}\")\n",
    "    arcpy.management.CopyFeatures(hex_layer, output_fc)\n",
    "    arcpy.AddMessage(f\"Adding output field '{output_field_name}'...\")\n",
    "    arcpy.management.AddField(output_fc, output_field_name, \"DOUBLE\",\n",
    "                              field_alias=output_field_alias)\n",
    "    arcpy.AddMessage(\"Updating output field with calculated values...\")\n",
    "    update_count = 0\n",
    "    null_count = 0\n",
    "    with arcpy.da.UpdateCursor(output_fc, [\"Input_FID\", output_field_name]) as cursor:\n",
    "        for row in cursor:\n",
    "            hex_id = row[0]\n",
    "            calculated_value = final_values.get(hex_id, None) # Default to None if no value calculated\n",
    "            row[1] = calculated_value\n",
    "            cursor.updateRow(row)\n",
    "            update_count += 1\n",
    "            if calculated_value is None:\n",
    "                null_count += 1\n",
    "    arcpy.AddMessage(f\"Updated {update_count} rows in '{os.path.basename(output_fc)}'.\")\n",
    "    if null_count > 0:\n",
    "         arcpy.AddMessage(f\"{null_count} hexagons received NULL values (no overlap or no valid data).\")\n",
    "def cleanup_intermediate(items_to_delete):\n",
    "    \"\"\"Deletes intermediate datasets.\"\"\"\n",
    "    arcpy.AddMessage(\"Cleaning up intermediate data...\")\n",
    "    deleted_count = 0\n",
    "    warning_count = 0\n",
    "    for item in items_to_delete:\n",
    "        if item and arcpy.Exists(item): # Check if path is defined and exists\n",
    "             try:\n",
    "                 arcpy.management.Delete(item)\n",
    "                 arcpy.AddMessage(f\"Deleted intermediate item: {item}\")\n",
    "                 deleted_count += 1\n",
    "             except Exception as del_err:\n",
    "                 arcpy.AddWarning(f\"Could not delete intermediate item: {item}. Error: {del_err}\")\n",
    "                 warning_count += 1\n",
    "        # else: arcpy.AddMessage(f\"Intermediate item not found or path not defined: {item}\") # Optional verbose message\n",
    "    if deleted_count == 0 and warning_count == 0:\n",
    "         arcpy.AddMessage(\"No intermediate items needed cleanup or found.\")\n",
    "# ---------------------------------------------------------------------------\n",
    "# Main Execution Logic\n",
    "# ---------------------------------------------------------------------------\n",
    "def main():\n",
    "    # --- Get Parameters ---\n",
    "    hex_layer = arcpy.GetParameterAsText(0)\n",
    "    overlay_layer = arcpy.GetParameterAsText(1)\n",
    "    value_field = arcpy.GetParameterAsText(2)\n",
    "    output_fc = arcpy.GetParameterAsText(3)\n",
    "    output_field_name_raw = arcpy.GetParameterAsText(4)\n",
    "    # --- Environment Settings ---\n",
    "    arcpy.env.overwriteOutput = True\n",
    "    temp_intersect_path = None # Initialize path variable\n",
    "    try:\n",
    "        # Define intermediate path using the scratch workspace\n",
    "        if not arcpy.env.scratchGDB or not arcpy.Exists(arcpy.env.scratchGDB):\n",
    "             default_scratch_folder = arcpy.env.scratchFolder\n",
    "             if default_scratch_folder and arcpy.Exists(default_scratch_folder):\n",
    "                 arcpy.env.scratchWorkspace = default_scratch_folder\n",
    "                 arcpy.AddWarning(f\"Scratch GDB not set or invalid, using Scratch Folder: {arcpy.env.scratchWorkspace}\")\n",
    "             else:\n",
    "                arcpy.AddError(\"Scratch Geodatabase or Scratch Folder is not set or accessible.\")\n",
    "                sys.exit()\n",
    "        temp_intersect_path = os.path.join(arcpy.env.scratchWorkspace, \"temp_agg_intersect\")\n",
    "        arcpy.AddMessage(f\"Using scratch location for intermediate data: {arcpy.env.scratchWorkspace}\")\n",
    "        # --- Validate Output Field Name ---\n",
    "        output_field_name = arcpy.ValidateFieldName(output_field_name_raw, os.path.dirname(output_fc))\n",
    "        if output_field_name != output_field_name_raw:\n",
    "            arcpy.AddWarning(f\"Output field name adjusted to '{output_field_name}' to be valid.\")\n",
    "        # --- Perform Core Logic ---\n",
    "        validate_inputs(hex_layer, overlay_layer, value_field)\n",
    "        overlay_props = get_overlay_properties(overlay_layer)\n",
    "        # Branch based on geometry type\n",
    "        if overlay_props['shape_type'] == \"Polyline\":\n",
    "            final_values = process_polylines(hex_layer, overlay_layer, value_field,\n",
    "                                             overlay_props['length_token'], temp_intersect_path)\n",
    "        elif overlay_props['shape_type'] == \"Polygon\":\n",
    "            final_values = process_polygons(hex_layer, overlay_layer, value_field,\n",
    "                                            overlay_props['oid_field'], overlay_props['area_token'],\n",
    "                                            temp_intersect_path)\n",
    "        else:\n",
    "            arcpy.AddError(f\"Unsupported geometry type for Input Overlay Layer: {overlay_props['shape_type']}\")\n",
    "            sys.exit()\n",
    "        # Create and populate the final output\n",
    "        create_and_populate_output(hex_layer, output_fc, output_field_name,\n",
    "                                   output_field_name_raw, final_values) # Pass raw name for alias\n",
    "        # --- Final Success Message ---\n",
    "        arcpy.AddMessage(\"-----------------------------------------\")\n",
    "        arcpy.AddMessage(\"Hexagons are the Bestagons! Script completed.\")\n",
    "        arcpy.AddMessage(\"-----------------------------------------\")\n",
    "    except arcpy.ExecuteError:\n",
    "        arcpy.AddError(f\"ArcPy Error: {arcpy.GetMessages(2)}\")\n",
    "    except SystemExit: # Catch sys.exit calls from helper functions\n",
    "         arcpy.AddError(\"Tool execution stopped due to validation or setup error.\")\n",
    "    except Exception as e:\n",
    "        arcpy.AddError(f\"An unexpected Python error occurred: {str(e)}\")\n",
    "        tb = sys.exc_info()[2]\n",
    "        tbinfo = ''.join(traceback.format_tb(tb, limit=5))\n",
    "        pymsg = f\"PYTHON TRACEBACK:\\nError Info: {str(sys.exc_info()[1])}\\n{tbinfo}\"\n",
    "        arcpy.AddError(pymsg)\n",
    "    finally:\n",
    "        # --- Cleanup ---\n",
    "        # Pass the list of items to potentially delete\n",
    "        cleanup_intermediate([temp_intersect_path])\n",
    "# --- Main execution block ---\n",
    "if __name__ == '__main__':\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ArcGISPro",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "version": "3.11.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
